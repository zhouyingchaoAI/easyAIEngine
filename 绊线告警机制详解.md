# 绊线告警机制详解

## 核心逻辑

**绊线统计服务只有在发生穿越且累积计数变化时才上传告警**

---

## 🎯 告警判断条件

```python
if total_crossed > last_count:
    # 累积计数增加 → 发生了新穿越 → 上传告警
    person_count = total_crossed - last_count
    trigger_alarm = True
else:
    # 累积计数未变化 → 无新穿越 → 不上传告警
    trigger_alarm = False
```

---

## 📊 工作流程示例

### 场景：门禁绊线统计

假设绊线位置在门口，统计进出人数：

```
初始状态：
  累积计数 = 0
  上次计数 = 0

────────────────────────────────────────────

时刻 T1: 检测到2人在场，但都没有穿越绊线
  ├─ 当前累积 = 0
  ├─ 上次计数 = 0
  ├─ 0 == 0 ? 是 → 无变化
  └─ 返回: {total_count: 2, 无person_count} → ❌ 不告警

────────────────────────────────────────────

时刻 T2: 1人穿越绊线（进门）
  ├─ 当前累积 = 1
  ├─ 上次计数 = 0
  ├─ 1 > 0 ? 是 → 有变化！
  ├─ 新增穿越 = 1 - 0 = 1
  ├─ 更新记录: 上次计数 = 1
  └─ 返回: {total_count: 2, person_count: 1} → ✅ 触发告警

────────────────────────────────────────────

时刻 T3: 检测到3人在场，但没有新穿越
  ├─ 当前累积 = 1（没变）
  ├─ 上次计数 = 1
  ├─ 1 == 1 ? 是 → 无变化
  └─ 返回: {total_count: 3, 无person_count} → ❌ 不告警

────────────────────────────────────────────

时刻 T4: 2人同时穿越绊线（进门）
  ├─ 当前累积 = 3
  ├─ 上次计数 = 1
  ├─ 3 > 1 ? 是 → 有变化！
  ├─ 新增穿越 = 3 - 1 = 2
  ├─ 更新记录: 上次计数 = 3
  └─ 返回: {total_count: 5, person_count: 2} → ✅ 触发告警

────────────────────────────────────────────

时刻 T5: 检测到1人在场，没有新穿越
  ├─ 当前累积 = 3（没变）
  ├─ 上次计数 = 3
  ├─ 3 == 3 ? 是 → 无变化
  └─ 返回: {total_count: 1, 无person_count} → ❌ 不告警
```

---

## 🔑 关键要点

### 1. 累积计数持续增长
```
第1次穿越 → 累积 = 1
第2次穿越 → 累积 = 2
第3次穿越 → 累积 = 3
...
24小时后 → 累积 = 0（自动清零）
```

### 2. 只有计数增加时才告警
```
累积：0 → 1  ✅ 告警 (person_count=1)
累积：1 → 1  ❌ 不告警
累积：1 → 3  ✅ 告警 (person_count=2)
累积：3 → 3  ❌ 不告警
```

### 3. 返回结果的区别

**有新穿越（上传告警）：**
```json
{
  "success": true,
  "result": {
    "objects": [检测到的人],
    "total_count": 2,
    "person_count": 1,  ← 关键！有这个字段
    "line_crossing": {
      "line_1": {
        "count": 15,    ← 累积总数
        "direction": "both"
      }
    }
  }
}
```

**无新穿越（不上传告警）：**
```json
{
  "success": true,
  "result": {
    "objects": [检测到的人],
    "total_count": 2,
    // 无 person_count 字段 ← 关键！
    "line_crossing": {
      "line_1": {
        "count": 15    ← 累积总数不变
      }
    }
  }
}
```

---

## 💡 上游系统如何处理

### 正确的告警判断逻辑

```python
# 伪代码
response = call_algorithm_api(image_url)

if response['success']:
    result = response['result']
    
    # 关键：检查 person_count 是否存在
    if 'person_count' in result:
        # 有新穿越，触发告警
        crossing_count = result['person_count']
        send_alarm(f"检测到 {crossing_count} 人穿越绊线")
        
        # 可以获取累积总数
        if 'line_crossing' in result:
            total = result['line_crossing']['line_1']['count']
            print(f"累积穿越总数: {total}")
    else:
        # 无新穿越，不触发告警
        # 但可以看到检测信息
        detected_count = result['total_count']
        print(f"检测到 {detected_count} 人在场，但无新穿越")
```

### ❌ 错误的判断逻辑

```python
# 错误示例1：只检查 total_count
if result['total_count'] > 0:
    send_alarm()  # 这样会一直告警 ❌

# 错误示例2：检查 line_crossing
if 'line_crossing' in result:
    send_alarm()  # 这样也会一直告警 ❌

# ✅ 正确做法：检查 person_count 是否存在
if 'person_count' in result and result['person_count'] > 0:
    send_alarm(result['person_count'])  # 只在有新穿越时告警 ✅
```

---

## 📝 日志示例

### 正常工作时的日志输出

```
时刻 14:30:10 - 第1次推理（有人在场，未穿越）
  收到推理请求 [14:30:10]
  任务ID: 门禁统计
  批量推理完成: 25ms
  跟踪器更新: 当前 2 个活跃跟踪器
  ℹ️  无新穿越（累计=0），不触发告警但保留检测信息
     返回结果: total_count=2, 无person_count
  推理完成: 总耗时 60ms
  → 上游不触发告警 ❌

────────────────────────────────────────────

时刻 14:30:15 - 第2次推理（1人穿越绊线）
  收到推理请求 [14:30:15]
  任务ID: 门禁统计
  批量推理完成: 26ms
  跟踪器更新: 当前 2 个活跃跟踪器
  [绊线统计] ID:5 跨线 line_1 (in) -> 累加: 1
  ✓ 检测到新穿越: 0 → 1 (+1)，触发告警
     返回结果: total_count=2, person_count=1
  推理完成: 总耗时 62ms
  → 上游触发告警 ✅

────────────────────────────────────────────

时刻 14:30:20 - 第3次推理（有人在场，未穿越）
  收到推理请求 [14:30:20]
  任务ID: 门禁统计
  批量推理完成: 24ms
  跟踪器更新: 当前 3 个活跃跟踪器
  ℹ️  无新穿越（累计=1），不触发告警但保留检测信息
     返回结果: total_count=3, 无person_count
  推理完成: 总耗时 58ms
  → 上游不触发告警 ❌

────────────────────────────────────────────

时刻 14:30:25 - 第4次推理（2人穿越绊线）
  收到推理请求 [14:30:25]
  任务ID: 门禁统计
  批量推理完成: 28ms
  跟踪器更新: 当前 4 个活跃跟踪器
  [绊线统计] ID:8 跨线 line_1 (in) -> 累加: 2
  [绊线统计] ID:9 跨线 line_1 (in) -> 累加: 3
  ✓ 检测到新穿越: 1 → 3 (+2)，触发告警
     返回结果: total_count=4, person_count=2
  推理完成: 总耗时 65ms
  → 上游触发告警 ✅（检测到2人新穿越）
```

---

## 🔍 如何验证告警逻辑

### 方法1：查看实时日志

```bash
# 启动服务
./start_line_crossing_service.sh

# 实时查看日志
tail -f /cv_space/predict/logs/line_crossing.log

# 观察日志输出：
# - 看到"✓ 检测到新穿越" → 会上传告警
# - 看到"ℹ️ 无新穿越" → 不会上传告警
```

### 方法2：通过Web界面监控

```bash
# 启动Web界面
./start_manager.sh

# 访问 http://localhost:7901
# 选择"绊线统计日志"
# 实时查看日志输出
```

### 方法3：手动测试API

```bash
# 发送多次请求，观察返回结果
for i in {1..5}; do
  curl -s -X POST http://localhost:7903/infer \
    -H "Content-Type: application/json" \
    -d '{
      "image_url": "http://10.1.6.230:9000/images/绊线人数统计/厕所统计/test.jpg",
      "task_id": "厕所统计",
      "task_type": "绊线人数统计"
    }' | jq '.result | {total_count, person_count}'
  
  sleep 2
done

# 观察 person_count 字段：
# - 第1次：如果有穿越 → 有 person_count
# - 第2次：如果无新穿越 → 无 person_count
# - 第3次：如果有新穿越 → 有 person_count
```

---

## 📈 累积计数机制

### 计数累积规则

```
时间 08:00 - 启动服务，累积计数 = 0
时间 08:30 - 1人穿越，累积 = 1  ✅ 告警(person_count=1)
时间 09:00 - 2人穿越，累积 = 3  ✅ 告警(person_count=2)
时间 10:00 - 0人穿越，累积 = 3  ❌ 不告警
时间 11:00 - 1人穿越，累积 = 4  ✅ 告警(person_count=1)
...
次日 08:00 - 自动清零，累积 = 0
```

### 计数清零时机

1. **服务重启** - 立即清零
2. **24小时自动** - 每天自动清零
3. **手动重启** - 停止再启动

```bash
# 手动清零（重启服务）
./停止所有服务.sh
./start_line_crossing_service.sh
```

---

## 🎯 告警类型对比

| 时刻 | 累积计数 | 计数变化 | person_count | 是否告警 | 告警内容 |
|------|---------|---------|-------------|---------|---------|
| T1 | 0 → 0 | 无 | - | ❌ | - |
| T2 | 0 → 1 | +1 | 1 | ✅ | 1人穿越 |
| T3 | 1 → 1 | 无 | - | ❌ | - |
| T4 | 1 → 3 | +2 | 2 | ✅ | 2人穿越 |
| T5 | 3 → 3 | 无 | - | ❌ | - |
| T6 | 3 → 5 | +2 | 2 | ✅ | 2人穿越 |

---

## 💻 代码实现

### 绊线统计服务代码

```python
# 计算当前总穿越数
total_crossed = sum(info['count'] for info in line_crossing_results.values())

# 获取上次的穿越数
last_count = LAST_CROSSING_COUNTS.get(task_id, 0)

if total_crossed > last_count:
    # 【有新穿越】→ 上传告警
    new_crossings = total_crossed - last_count
    result_data['person_count'] = new_crossings  # 设置 person_count
    LAST_CROSSING_COUNTS[task_id] = total_crossed  # 更新记录
    
    print(f"✓ 检测到新穿越: {last_count} → {total_crossed} (+{new_crossings})，触发告警")
    print(f"  返回结果: total_count={result_data['total_count']}, person_count={new_crossings}")
    # → 上游收到 person_count → 触发告警
else:
    # 【无新穿越】→ 不上传告警
    print(f"ℹ️ 无新穿越（累计={total_crossed}），不触发告警但保留检测信息")
    print(f"  返回结果: total_count={result_data['total_count']}, 无person_count")
    # → 上游没有 person_count → 不触发告警
```

---

## 🎨 返回结果详解

### 完整返回结果（有新穿越）

```json
{
  "success": true,
  "result": {
    "objects": [
      {
        "class": "head",
        "confidence": 0.89,
        "bbox": [100, 200, 150, 250]
      },
      {
        "class": "head",
        "confidence": 0.92,
        "bbox": [300, 180, 350, 230]
      }
    ],
    "total_count": 2,           ← 检测到的物体总数
    "person_count": 1,          ← 新增穿越人数（触发告警的关键）
    "line_crossing": {
      "line_1": {
        "region_name": "进门线",
        "count": 15,            ← 累积穿越总数
        "direction": "both"
      }
    }
  },
  "confidence": 0.905,
  "inference_time_ms": 45
}
```

### 字段说明

| 字段 | 含义 | 何时存在 | 用途 |
|------|------|---------|------|
| `objects` | 检测到的物体列表 | 总是 | 显示检测结果 |
| `total_count` | 检测到的物体总数 | 总是 | 显示在场人数 |
| `person_count` | 新增穿越人数 | **只在有新穿越时** | **触发告警的关键** |
| `line_crossing` | 绊线统计信息 | 有绊线结果时 | 显示累积统计 |

---

## 🔔 告警触发条件总结

### ✅ 会触发告警的情况

1. **第一次有人穿越**
   - 累积：0 → 1
   - person_count: 1

2. **有新的人穿越**
   - 累积：5 → 6
   - person_count: 1

3. **多人同时穿越**
   - 累积：10 → 13
   - person_count: 3

4. **服务重启后首次穿越**
   - 累积：0 → 1
   - person_count: 1

### ❌ 不会触发告警的情况

1. **有人在场但未穿越**
   - 累积：5 → 5（不变）
   - 无 person_count

2. **检测到物体但没有跟踪器**
   - 无法判断是否穿越
   - 无 person_count

3. **累积计数未变化**
   - 累积：10 → 10（不变）
   - 无 person_count

4. **无人在场**
   - 累积：15 → 15（不变）
   - 无 person_count

---

## 🧪 测试用例

### 测试1：首次穿越

```bash
# 1. 重启服务（重置计数器）
./停止所有服务.sh
./start_line_crossing_service.sh

# 2. 等待有人穿越

# 3. 查看日志
grep "检测到新穿越" /cv_space/predict/logs/line_crossing.log | tail -1

# 预期输出：
# ✓ 检测到新穿越: 0 → 1 (+1)，触发告警
```

### 测试2：持续检测（无新穿越）

```bash
# 1. 发送多次请求（模拟持续检测）
for i in {1..5}; do
  curl -s http://localhost:7903/infer ... 
  sleep 2
done

# 2. 查看日志
grep -E "检测到新穿越|无新穿越" /cv_space/predict/logs/line_crossing.log | tail -10

# 预期：只有第一次有"检测到新穿越"，后续都是"无新穿越"
```

### 测试3：再次穿越

```bash
# 等待有新的人穿越绊线

# 查看日志
grep "检测到新穿越" /cv_space/predict/logs/line_crossing.log | tail -2

# 预期输出：
# ✓ 检测到新穿越: 0 → 1 (+1)，触发告警
# ✓ 检测到新穿越: 1 → 2 (+1)，触发告警
```

---

## 🎯 核心逻辑确认

### ✅ 当前实现（正确）

```
条件：total_crossed > last_count
  ├─ True  → 设置 person_count → 上传告警 ✅
  └─ False → 不设置 person_count → 不上传告警 ✅
```

### 工作机制

```
1. 检测物体 → 生成 objects 和 total_count（总是）
2. 跟踪物体 → 更新跟踪器
3. 检测绊线 → 判断是否穿越
4. 累积计数 → 增加 line_crossing.count
5. 比较计数 → 判断是否有变化
6. 设置字段 → 有变化才设置 person_count
7. 返回结果 → person_count 决定是否告警
```

---

## 📊 与实时检测服务的对比

| 特性 | 实时检测服务 | 绊线统计服务 |
|------|------------|------------|
| **告警条件** | 检测到物体 | 累积计数变化 |
| **person_count** | 总是有 | 只在穿越时有 |
| **告警频率** | 每次推理 | 只在穿越时 |
| **适用场景** | 实时监控 | 累积统计 |

---

## ✅ 确认清单

当前绊线统计服务的告警机制是：

- [x] 只在累积计数变化时才设置 person_count
- [x] person_count 的值等于新增穿越人数
- [x] 无新穿越时不设置 person_count（不触发告警）
- [x] 始终保留检测信息（objects, total_count）
- [x] 上游系统通过检查 person_count 字段判断是否告警

**这个逻辑已经正确实现！** ✅

---

Happy detecting! 🎯

